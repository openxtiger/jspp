/**
 * @pakcage jui.form
 */
'package jui.form'.j(function () {
    /**
     * @class jui.form.ComboBox
     * @extends jui.form.TriggerField
     */
    'class ComboBox extends TriggerField'.j(function () {

        jprotected({
            defaultAutoCreate: {tag: "input", type: "text", size: "24", autocomplete: "off"},
            /**
             * @cfg {Number} listWidth The width (used as a parameter to {@link Ext.Element#setWidth}) of the dropdown
             * list (defaults to the width of the ComboBox field).  See also <tt>{@link #minListWidth}
             */
            /**
             * @event expand
             * Fires when the dropdown list is expanded
             */
            /**
             * @event collapse
             * Fires when the dropdown list is collapsed
             */

            /**
             * @event beforeselect
             * Fires before a list item is selected. Return false to cancel the selection.
             */
            /**
             * @event select
             * Fires when a list item is selected
             */
            /**
             * @event beforequery
             * Fires before all queries are processed. Return false to cancel the query or set the queryEvent's
             * cancel property to true.
             */
            /**
             * @cfg {String} displayField The underlying {@link Ext.data.Field#name data field name} to binding to this
             * ComboBox (defaults to undefined if <tt>{@link #mode} = 'remote'</tt> or <tt>'field1'</tt> if
             * {@link #transform transforming a select} or if the {@link #store field name is autogenerated based on
             * the store configuration}).
             * <p>See also <tt>{@link #valueField}</tt>.</p>
             * <p><b>Note</b>: if using a ComboBox in an {@link Ext.grid.EditorGridPanel Editor Grid} a
             * {@link Ext.grid.Column#renderer renderer} will be needed to show the displayField when the editor is not
             * active.</p>
             */
            /**
             * @cfg {String} valueField The underlying {@link Ext.data.Field#name data value name} to binding to this
             * ComboBox (defaults to undefined if <tt>{@link #mode} = 'remote'</tt> or <tt>'field2'</tt> if
             * {@link #transform transforming a select} or if the {@link #store field name is autogenerated based on
             * the store configuration}).
             * <p><b>Note</b>: use of a <tt>valueField</tt> requires the user to make a selection in order for a value to be
             * mapped.  See also <tt>{@link #hiddenName}</tt>, <tt>{@link #hiddenValue}</tt>, and <tt>{@link #displayField}</tt>.</p>
             */
            /**
             * @cfg {String} hiddenName If specified, a hidden form field with this name is dynamically generated to store the
             * field's data value (defaults to the underlying DOM element's name). Required for the combo's value to automatically
             * post during a form submission.  See also {@link #valueField}.
             * <p><b>Note</b>: the hidden field's id will also default to this name if {@link #hiddenId} is not specified.
             * The ComboBox {@link Ext.Component#id id} and the <tt>{@link #hiddenId}</tt> <b>should be different</b>, since
             * no two DOM nodes should share the same id.  So, if the ComboBox <tt>{@link Ext.form.Field#name name}</tt> and
             * <tt>hiddenName</tt> are the same, you should specify a unique <tt>{@link #hiddenId}</tt>.</p>
             */
            /**
             * @cfg {String} hiddenId If <tt>{@link #hiddenName}</tt> is specified, <tt>hiddenId</tt> can also be provided
             * to give the hidden field a unique id (defaults to the <tt>{@link #hiddenName}</tt>).  The <tt>hiddenId</tt>
             * and combo {@link Ext.Component#id id} should be different, since no two DOM
             * nodes should share the same id.
             */
            /**
             * @cfg {String} hiddenValue Sets the initial value of the hidden field if {@link #hiddenName} is
             * specified to contain the selected {@link #valueField}, from the Store. Defaults to the configured
             * <tt>{@link Ext.form.Field#value value}</tt>.
             */
            /**
             * @cfg {String} listClass The CSS class to add to the predefined <tt>'x-combo-list'</tt> class
             * applied the dropdown list element (defaults to '').
             */
            listClass: '',
            /**
             * @cfg {String} selectedClass CSS class to apply to the selected item in the dropdown list
             * (defaults to <tt>'x-combo-selected'</tt>)
             */
            selectedClass: 'j-combo-selected',
            /**
             * @cfg {String} listEmptyText The empty text to display in the data view if no items are found.
             * (defaults to '')
             */
            listEmptyText: '',
            /**
             * @cfg {String} triggerClass An additional CSS class used to style the trigger button.  The trigger will always
             * get the class <tt>'x-form-trigger'</tt> and <tt>triggerClass</tt> will be <b>appended</b> if specified
             * (defaults to <tt>'x-form-arrow-trigger'</tt> which displays a downward arrow icon).
             */
            triggerClass: 'j-form-arrow-trigger',
            /**
             * @cfg {Boolean/String} shadow <tt>true</tt> or <tt>"sides"</tt> for the default effect, <tt>"frame"</tt> for
             * 4-way shadow, and <tt>"drop"</tt> for bottom-right
             */
            shadow: 'sides',
            /**
             * @cfg {String/Array} listAlign A valid anchor position value. See <tt>{@link Ext.Element#alignTo}</tt> for details
             * on supported anchor positions and offsets. To specify x/y offsets as well, this value
             * may be specified as an Array of <tt>{@link Ext.Element#alignTo}</tt> method arguments.</p>
             * <pre><code>[ 'tl-bl?', [6,0] ]</code></pre>(defaults to <tt>'tl-bl?'</tt>)
             */
            listAlign: 'tl-bl?',
            /**
             * @cfg {Number} maxHeight The maximum height in pixels of the dropdown list before scrollbars are shown
             * (defaults to <tt>300</tt>)
             */
            maxHeight: 300,
            /**
             * @cfg {Number} minHeight The minimum height in pixels of the dropdown list when the list is constrained by its
             * distance to the viewport edges (defaults to <tt>90</tt>)
             */
            minHeight: 90,
            /**
             * @cfg {String} triggerAction The action to execute when the trigger is clicked.
             * <div class="mdetail-params"><ul>
             * <li><b><tt>'query'</tt></b> : <b>Default</b>
             * <p class="sub-desc">{@link #doQuery run the query} using the {@link Ext.form.Field#getRawValue raw value}.</p></li>
             * <li><b><tt>'all'</tt></b> :
             * <p class="sub-desc">{@link #doQuery run the query} specified by the <tt>{@link #allQuery}</tt> config option</p></li>
             * </ul></div>
             * <p>See also <code>{@link #queryParam}</code>.</p>
             */
            triggerAction: 'query',
            /**
             * @cfg {Number} minChars The minimum number of characters the user must type before autocomplete and
             * {@link #typeAhead} activate (defaults to <tt>4</tt> if <tt>{@link #mode} = 'remote'</tt> or <tt>0</tt> if
             * <tt>{@link #mode} = 'local'</tt>, does not apply if
             * <tt>{@link Ext.form.TriggerField#editable editable} = false</tt>).
             */
            minChars: 4,
            /**
             * @cfg {Boolean} autoSelect <tt>true</tt> to select the first result gathered by the data store (defaults
             * to <tt>true</tt>).  A false value would require a manual selection from the dropdown list to set the components value
             * unless the value of ({@link #typeAheadDelay}) were true.
             */
            autoSelect: true,
            /**
             * @cfg {Boolean} typeAhead <tt>true</tt> to populate and autoselect the remainder of the text being
             * typed after a configurable delay ({@link #typeAheadDelay}) if it matches a known value (defaults
             * to <tt>false</tt>)
             */
            typeAhead: false,
            /**
             * @cfg {Number} queryDelay The length of time in milliseconds to delay between the start of typing and
             * sending the query to filter the dropdown list (defaults to <tt>500</tt> if <tt>{@link #mode} = 'remote'</tt>
             * or <tt>10</tt> if <tt>{@link #mode} = 'local'</tt>)
             */
            queryDelay: 500,
            /**
             * @cfg {Number} pageSize If greater than <tt>0</tt>, a {@link Ext.PagingToolbar} is displayed in the
             * footer of the dropdown list and the {@link #doQuery filter queries} will execute with page start and
             * {@link Ext.PagingToolbar#pageSize limit} parameters. Only applies when <tt>{@link #mode} = 'remote'</tt>
             * (defaults to <tt>0</tt>).
             */
            pageSize: 0,
            /**
             * @cfg {Boolean} selectOnFocus <tt>true</tt> to select any existing text in the field immediately on focus.
             * Only applies when <tt>{@link Ext.form.TriggerField#editable editable} = true</tt> (defaults to
             * <tt>false</tt>).
             */
            selectOnFocus: false,
            /**
             * @cfg {String} queryParam Name of the query ({@link Ext.data.Store#baseParam baseParam} name for the store)
             * as it will be passed on the querystring (defaults to <tt>'query'</tt>)
             */
            queryParam: 'query',
            /**
             * @cfg {String} loadingText The text to display in the dropdown list while data is loading.  Only applies
             * when <tt>{@link #mode} = 'remote'</tt> (defaults to <tt>'Loading...'</tt>)
             */
            loadingText: 'Loading...',
            /**
             * @cfg {Boolean} resizable <tt>true</tt> to add a resize handle to the bottom of the dropdown list
             * (creates an {@link Ext.Resizable} with 'se' {@link Ext.Resizable#pinned pinned} handles).
             * Defaults to <tt>false</tt>.
             */
            resizable: false,
            /**
             * @cfg {Number} handleHeight The height in pixels of the dropdown list resize handle if
             * <tt>{@link #resizable} = true</tt> (defaults to <tt>8</tt>)
             */
            handleHeight: 8,
            /**
             * @cfg {String} allQuery The text query to send to the server to return all records for the list
             * with no filtering (defaults to '')
             */
            allQuery: '',
            /**
             * @cfg {String} mode Acceptable values are:
             * <div class="mdetail-params"><ul>
             * <li><b><tt>'remote'</tt></b> : <b>Default</b>
             * <p class="sub-desc">Automatically loads the <tt>{@link #store}</tt> the <b>first</b> time the trigger
             * is clicked. If you do not want the store to be automatically loaded the first time the trigger is
             * clicked, set to <tt>'local'</tt> and manually load the store.  To force a requery of the store
             * <b>every</b> time the trigger is clicked see <tt>{@link #lastQuery}</tt>.</p></li>
             * <li><b><tt>'local'</tt></b> :
             * <p class="sub-desc">ComboBox loads local data</p>
             * <pre><code>
             * </code></pre></li>
             * </ul></div>
             */
            mode: 'remote',
            /**
             * @cfg {Number} minListWidth The minimum width of the dropdown list in pixels (defaults to <tt>70</tt>, will
             * be ignored if <tt>{@link #listWidth}</tt> has a higher value)
             */
            minListWidth: 70,
            /**
             * @cfg {Boolean} forceSelection <tt>true</tt> to restrict the selected value to one of the values in the list,
             * <tt>false</tt> to allow the user to set arbitrary text into the field (defaults to <tt>false</tt>)
             */
            forceSelection: false,
            /**
             * @cfg {Number} typeAheadDelay The length of time in milliseconds to wait until the typeahead text is displayed
             * if <tt>{@link #typeAhead} = true</tt> (defaults to <tt>250</tt>)
             */
            typeAheadDelay: 250,
            /**
             * @cfg {String} valueNotFoundText When using a name/value combo, if the value passed to setValue is not found in
             * the store, valueNotFoundText will be displayed as the field text if defined (defaults to undefined). If this
             * default text is used, it means there is no value set and no validation will occur on this field.
             */

            /**
             * @cfg {Boolean} lazyInit <tt>true</tt> to not initialize the list for this combo until the field is focused
             * (defaults to <tt>true</tt>)
             */
            lazyInit: false,

            /**
             * @cfg {Boolean} clearFilterOnReset <tt>true</tt> to clear any filters on the store (when in local mode) when reset is called
             * (defaults to <tt>true</tt>)
             */
            clearFilterOnReset: true,

            /**
             * @cfg {Boolean} submitValue False to clear the name attribute on the field so that it is not submitted during a form post.
             * If a hiddenName is specified, setting this to true will cause both the hidden field and the element to be submitted.
             * Defaults to <tt>undefined</tt>.
             */
            submitValue: undefined
        });

        jprotected({
            initComponent: function () {
                jsuper(this);

                if (this.transform) {
                    var s = $.dom(this.transform);
                    if (!this.hiddenName) {
                        this.hiddenName = s.name;
                    }
                    if (!this.store) {
                        this.mode = 'local';
                        var d = [], opts = s.options;
                        for (var i = 0, len = opts.length; i < len; i++) {
                            var o = opts[i],
                                value = (o.hasAttribute ? o.hasAttribute('value') : o.getAttributeNode('value').specified) ? o.value : o.text;
                            if (o.selected && $.isEmpty(this.value, true)) {
                                this.value = value;
                            }
                            d.push([value, o.text]);
                        }
                        this.store = new Ext.data.ArrayStore({
                            'id': 0,
                            fields: ['value', 'text'],
                            data: d,
                            autoDestroy: true
                        });
                        this.valueField = 'value';
                        this.displayField = 'text';
                    }
                    s.name = $.id(); // wipe out the name in case somewhere else they have a reference
                    if (!this.lazyRender) {
                        this.target = true;
                        this.el = $.insertBefore(s, this.autoCreate || this.defaultAutoCreate);
                        this.render(this.el.parentNode, s);
                    }
                    $.remove(s);
                }
                //auto-configure store from local array data
                else if (this.jde) {
                    /*if (this.store.autoCreated) {
                     this.displayField = this.valueField = 'field1';
                     if (!this.store.expandData) {
                     this.displayField = 'field2';
                     }
                     this.mode = 'local';
                     }*/
                }

                this.selectedIndex = -1;
                if (this.mode == 'local') {
                    if (!$.isDefined(this.initialConfig.queryDelay)) {
                        this.queryDelay = 10;
                    }
                    if (!$.isDefined(this.initialConfig.minChars)) {
                        this.minChars = 0;
                    }
                }
            },

            // private
            onRender: function (ct, position) {
                if (this.hiddenName && !$.isDefined(this.submitValue)) {
                    this.submitValue = false;
                }
                jsuper(this);
                if (this.hiddenName) {
                    this.hiddenField = $.insertBefore(this.el, {tag: 'input', type: 'hidden', name: this.hiddenName,
                        id: (this.hiddenId || this.hiddenName)}, true);

                }
                this.el.dom().setAttribute('autocomplete', 'off');

                if (!this.lazyInit) {
                    this.initList();
                } else {
                    this.el.on('focus', this.initList, this);
                }
            },

            // private
            initValue: function () {
                jsuper(this);
                if (this.hiddenField) {
                    this.hiddenField.value = $.isDefined(this.hiddenValue) ? this.hiddenValue : this.value;
                }
            },

            getParentZIndex: function () {
                var zindex;
                if (this.ownerCt) {
                    this.findParentBy(function (ct) {
                        zindex = parseInt(ct.getPositionEl().css('z-index'), 10);
                        return !!zindex;
                    });
                }
                return zindex;
            },

            // private
            initList: function () {
                if (!this.list) {
                    var cls = 'j-combo-list',
                        listParent = $.dom(this.getListParent() || $.getBody()),
                        zindex = parseInt($(listParent).css('z-index'), 10);

                    /*if (!zindex) {
                     zindex = this.getParentZIndex();
                     }*/

                    this.list = new jui.Layer({
                        parentEl: listParent,
                        shadow: this.shadow,
                        cls: [cls, this.listClass].join(' '),
                        constrain: false,
                        zindex: (zindex || 12000) + 5
                    });

                    var lw = this.listWidth || Math.max(this.wrap.width(), this.minListWidth);
                    this.list.size(lw, 0);
                    //this.list.swallowEvent('mousewheel');
                    this.assetHeight = 0;
                    if (this.syncFont !== false) {
                        this.list.css('font-size', this.el.css('font-size'));
                    }
                    if (this.title) {
                        this.header = this.list.createChild({cls: cls + '-hd', html: this.title});
                        this.assetHeight += this.header.height();
                    }
                    this.innerList = this.list.createChild({cls: cls + '-inner'});
                    this.innerList.on('mouseover', this.onViewOver, this);
                    this.innerList.on('mousemove', this.onViewMove, this);
                    this.innerList.width(lw /*- this.list.getFrameWidth('lr')*/);

                    /*if (this.pageSize) {
                     this.footer = this.list.createChild({cls: cls + '-ft'});
                     this.pageTb = new Ext.PagingToolbar({
                     store: this.store,
                     pageSize: this.pageSize,
                     renderTo: this.footer
                     });
                     this.assetHeight += this.footer.height();
                     }*/

                    if (!this.tpl) {
                        this.tpl = '<tpl for="."><div class="' + cls + '-item">{' + this.displayField + '}</div></tpl>';
                    }

                    /**
                     * The {@link jui.DataView DataView} used to display the ComboBox's options.
                     * @type jui.DataView
                     */
                    this.view = $$('dataview', {
                        applyTo: this.innerList,
                        tpl: this.tpl,
                        singleSelect: true,
                        selectedClass: this.selectedClass,
                        itemSelector: this.itemSelector || '.' + cls + '-item',
                        emptyText: this.listEmptyText,
                        deferEmptyText: false
                    });

                    /*this.mon(this.view, {
                     containerclick: this.onViewClick,
                     click: this.onViewClick,
                     scope: this
                     });*/

                    this.bindJDE(this.jde, true);

                    /*if (this.resizable) {
                     this.resizer = new Ext.Resizable(this.list, {
                     pinned: true, handles: 'se'
                     });
                     this.mon(this.resizer, 'resize', function (r, w, h) {
                     this.maxHeight = h - this.handleHeight - this.list.getFrameWidth('tb') - this.assetHeight;
                     this.listWidth = w;
                     this.innerList.setWidth(w - this.list.getFrameWidth('lr'));
                     this.restrictHeight();
                     }, this);

                     this[this.pageSize ? 'footer' : 'innerList'].setStyle('margin-bottom', this.handleHeight + 'px');
                     }*/
                }
            },

            /**
             * <p>Returns the element used to house this ComboBox's pop-up list. Defaults to the document body.</p>
             * A custom implementation may be provided as a configuration option if the floating list needs to be rendered
             * to a different Element. An example might be rendering the list inside a Menu so that clicking
             * the list does not hide the Menu:<pre><code>
             */
            getListParent: function () {
                return document.body;
            },

            /**
             * Returns the store associated with this combo.
             * @return {Ext.data.Store} The store
             */
            getStore: function () {
                return this.store;
            },

            // private
            bindJDE: function (jde, initial) {
                if (this.jde && !initial) {
                    if (this.jde !== jde && this.jde.autoDestroy) {
                        this.jde.destroy();
                    } else {
                        this.jde.off('beforeload', this.onBeforeLoad, this);
                        this.jde.off('load', this.onLoad, this);
                        this.jde.off('exception', this.collapse, this);
                    }
                    if (!jde) {
                        this.jde = null;
                        if (this.view) {
                            this.view.bindJDE(null);
                        }
                        /*if (this.pageTb) {
                         this.pageTb.bindStore(null);
                         }*/
                    }
                }
                if (jde) {
                    if (!initial) {
                        this.lastQuery = null;
                        /*if (this.pageTb) {
                         this.pageTb.bindStore(store);
                         }*/
                    }

                    this.jde.on('beforeload', this.onBeforeLoad, this);
                    this.jde.on('load', this.onLoad, this);
                    this.jde.on('exception', this.collapse, this);

                    if (this.view) {
                        this.view.bindJDE(jde);
                    }
                }
            },

            reset: function () {
                jsuper(this);
                if (this.clearFilterOnReset && this.mode == 'local') {
                    this.store.clearFilter();
                }
            },

            // private
            initEvents: function () {
                jsuper(this);


                /*this.keyNav = new Ext.KeyNav(this.el, {
                 "up": function (e) {
                 this.inKeyMode = true;
                 this.selectPrev();
                 },

                 "down": function (e) {
                 if (!this.isExpanded()) {
                 this.onTriggerClick();
                 } else {
                 this.inKeyMode = true;
                 this.selectNext();
                 }
                 },

                 "enter": function (e) {
                 this.onViewClick();
                 },

                 "esc": function (e) {
                 this.collapse();
                 },

                 "tab": function (e) {
                 if (this.forceSelection === true) {
                 this.collapse();
                 } else {
                 this.onViewClick(false);
                 }
                 return true;
                 },

                 scope: this,

                 doRelay: function (e, h, hname) {
                 if (hname == 'down' || this.scope.isExpanded()) {
                 // this MUST be called before ComboBox#fireKey()
                 var relay = Ext.KeyNav.prototype.doRelay.apply(this, arguments);
                 if (!Ext.isIE && Ext.EventManager.useKeydown) {
                 // call Combo#fireKey() for browsers which use keydown event (except IE)
                 this.scope.fireKey(e);
                 }
                 return relay;
                 }
                 return true;
                 },

                 forceKeyDown: true,
                 defaultEventAction: 'stopEvent'
                 });*/

                this.queryDelay = Math.max(this.queryDelay || 10,
                    this.mode == 'local' ? 10 : 250);
                this.dqTask = $.delay(this.initQuery, this);
                if (this.typeAhead) {
                    this.taTask = $.delay(this.onTypeAhead, this);
                }
                if (!this.enableKeyEvents) {
                    this.el.on('keyup', this.onKeyUp, this);
                }
            },


            // private
            onDestroy: function () {
                if (this.dqTask) {
                    this.dqTask.cancel();
                    this.dqTask = null;
                }
                this.bindJDE(null);
                $.destroy(
                    /* this.resizer,*/
                    this.view,
                    /*this.pageTb,*/
                    this.list
                );
                //Ext.destroyMembers(this, 'hiddenField');
                jsuper(this);
            },

            // private
            fireKey: function (e) {
                if (!this.isExpanded()) {
                    jsuper(this);
                }
            },

            // private
            onResize: function (w, h) {
                jsuper(this);
                if (!isNaN(w) && this.isVisible() && this.list) {
                    this.doResize(w);
                } else {
                    this.bufferSize = w;
                }
            },

            doResize: function (w) {
                if (!$.isDefined(this.listWidth)) {
                    var lw = Math.max(w, this.minListWidth);
                    this.list.width(lw);
                    this.innerList.width(lw /*- this.list.getFrameWidth('lr')*/);
                }
            },

            // private
            onEnable: function () {
                jsuper(this);
                if (this.hiddenField) {
                    this.hiddenField.disabled = false;
                }
            },

            // private
            onDisable: function () {
                jsuper(this);
                if (this.hiddenField) {
                    this.hiddenField.disabled = true;
                }
            },

            // private
            onBeforeLoad: function () {
                if (!this.hasFocus) {
                    return;
                }
                this.innerList.update(this.loadingText ?
                    '<div class="loading-indicator">' + this.loadingText + '</div>' : '');
                this.restrictHeight();
                this.selectedIndex = -1;
            },

            // private
            onLoad: function () {
                if (!this.hasFocus) {
                    return;
                }
                if (this.jde.getCount() > 0 || this.listEmptyText) {
                    this.expand();
                    this.restrictHeight();
                    if (this.lastQuery == this.allQuery) {
                        if (this.editable) {
                            this.el.dom().select();
                        }
                        /*if (this.autoSelect !== false && !this.selectByValue(this.value, true)) {
                         this.select(0, true);
                         }*/
                    } else {
                        if (this.autoSelect !== false) {
                            this.selectNext();
                        }
                        if (this.typeAhead && this.lastKey != $.event.BACKSPACE && this.lastKey != Ext.EventObject.DELETE) {
                            this.taTask.delay(this.typeAheadDelay);
                        }
                    }
                } else {
                    this.collapse();
                }

            },

            // private
            onTypeAhead: function () {
                if (this.jde.getCount() > 0) {
                    var r = this.store.getAt(0);
                    var newValue = r.data[this.displayField];
                    var len = newValue.length;
                    var selStart = this.getRawValue().length;
                    if (selStart != len) {
                        this.setRawValue(newValue);
                        this.selectText(selStart, newValue.length);
                    }
                }
            },

            // private
            assertValue: function () {
                var val = this.getRawValue(),
                    rec = this.findRecord(this.displayField, val);

                if (!rec && this.forceSelection) {
                    if (val.length > 0) {
                        this.el.dom.value = this.lastSelectionText;
                    } else {
                        this.clearValue();
                    }
                } else {
                    if (rec) {
                        // onSelect may have already set the value and by doing so
                        // set the display field properly.  Let's not wipe out the
                        // valueField here by just sending the displayField.
                        if (val == rec.get(this.displayField) && this.value == rec.get(this.valueField)) {
                            return;
                        }
                        val = rec.get(this.valueField || this.displayField);
                    }
                    this.setValue(val);
                }
            },

            // private
            onSelect: function (record, index) {
                if (this.fireEvent('beforeselect', this, record, index) !== false) {
                    this.setValue(record.data[this.valueField || this.displayField]);
                    this.collapse();
                    this.fireEvent('select', this, record, index);
                }
            },

            // inherit docs
            getName: function () {
                var hf = this.hiddenField;
                return hf && hf.name ? hf.name : this.hiddenName || Ext.form.ComboBox.superclass.getName.call(this);
            },

            /**
             * Returns the currently selected field value or empty string if no value is set.
             * @return {String} value The selected value
             */
            getValue: function () {
                if (this.valueField) {
                    return $.isDefined(this.value) ? this.value : '';
                } else {
                    return jsuper(this);
                }
            },

            /**
             * Clears any text/value currently set in the field
             */
            clearValue: function () {
                if (this.hiddenField) {
                    this.hiddenField.value = '';
                }
                this.setRawValue('');
                this.lastSelectionText = '';
                this.value = '';
            },

            /**
             * Sets the specified value into the field.  If the value finds a match, the corresponding record text
             * will be displayed in the field.  If the value does not match the data value of an existing item,
             * and the valueNotFoundText config option is defined, it will be displayed as the default field text.
             * Otherwise the field will be blank (although the value will still be set).
             * @param {String} value The value to match
             * @return {Ext.form.Field} this
             */
            setValue: function (v) {
                var text = v;
                if (this.valueField) {
                    var r = this.findRecord(this.valueField, v);
                    if (r) {
                        text = r.data[this.displayField];
                    } else if ($.isDefined(this.valueNotFoundText)) {
                        text = this.valueNotFoundText;
                    }
                }
                this.lastSelectionText = text;
                if (this.hiddenField) {
                    this.hiddenField.value = Ext.value(v, '');
                }
                jsuper(this);
                this.value = v;
                return this;
            },

            // private
            findRecord: function (prop, value) {
                var record;
                if (this.store.getCount() > 0) {
                    this.store.each(function (r) {
                        if (r.data[prop] == value) {
                            record = r;
                            return false;
                        }
                    });
                }
                return record;
            },

            // private
            onViewMove: function (e, t) {
                this.inKeyMode = false;
            },

            // private
            onViewOver: function (e, t) {
                if (this.inKeyMode) { // prevent key nav and mouse over conflicts
                    return;
                }
                var item = this.view.findItemFromChild(t);
                if (item) {
                    var index = this.view.indexOf(item);
                    this.select(index, false);
                }
            },

            // private
            onViewClick: function (doFocus) {
                var index = this.view.getSelectedIndexes()[0],
                    s = this.store,
                    r = s.getAt(index);
                if (r) {
                    this.onSelect(r, index);
                } else {
                    this.collapse();
                }
                if (doFocus !== false) {
                    this.el.focus();
                }
            },


            // private
            restrictHeight: function () {
                this.innerList.dom().style.height = '';
                var inner = this.innerList.dom(),
                    pad = /*this.list.border('tb') */+(this.resizable ? this.handleHeight : 0) + this.assetHeight,
                    h = Math.max(inner.clientHeight, inner.offsetHeight, inner.scrollHeight),
                    ha = this.list.position().top - $.getBody().scrollTop(),
                    hb = $.height() - ha - this.list.height(),
                    space = Math.max(ha, hb, this.minHeight || 0) - this.list.shadowOffset - pad - 5;

                //h = Math.min(h, space, this.maxHeight);

                this.innerList.height(h);
                //this.list.beginUpdate();
                this.list.height(h + pad);
                //this.list.alignTo.apply(this.list, [this.el].concat(this.listAlign));
                //this.list.endUpdate();
            },

            /**
             * Returns true if the dropdown list is expanded, else false.
             */
            isExpanded: function () {
                return this.list && this.list.isVisible();
            },

            /**
             * Select an item in the dropdown list by its data value. This function does NOT cause the select event to fire.
             * The store must be loaded and the list expanded for this function to work, otherwise use setValue.
             * @param {String} value The data value of the item to select
             * @param {Boolean} scrollIntoView False to prevent the dropdown list from autoscrolling to display the
             * selected item if it is not currently in view (defaults to true)
             * @return {Boolean} True if the value matched an item in the list, else false
             */
            selectByValue: function (v, scrollIntoView) {
                if (!$.isEmpty(v, true)) {
                    var r = this.findRecord(this.valueField || this.displayField, v);
                    if (r) {
                        this.select(this.store.indexOf(r), scrollIntoView);
                        return true;
                    }
                }
                return false;
            },

            /**
             * Select an item in the dropdown list by its numeric index in the list. This function does NOT cause the select event to fire.
             * The store must be loaded and the list expanded for this function to work, otherwise use setValue.
             * @param {Number} index The zero-based index of the list item to select
             * @param {Boolean} scrollIntoView False to prevent the dropdown list from autoscrolling to display the
             * selected item if it is not currently in view (defaults to true)
             */
            select: function (index, scrollIntoView) {
                this.view.select(index);
                if (scrollIntoView !== false) {
                    var el = this.view.getNode(index);
                    if (el) {
                        this.innerList.scrollChildIntoView(el, false);
                    }
                }

            },

            // private
            selectNext: function () {
                var ct = this.jde.getCount();
                if (ct > 0) {
                    if (this.selectedIndex == -1) {
                        this.select(0);
                    } else if (this.selectedIndex < ct - 1) {
                        this.select(this.selectedIndex + 1);
                    }
                }
            },

            // private
            selectPrev: function () {
                var ct = this.store.getCount();
                if (ct > 0) {
                    if (this.selectedIndex == -1) {
                        this.select(0);
                    } else if (this.selectedIndex !== 0) {
                        this.select(this.selectedIndex - 1);
                    }
                }
            },

            // private
            onKeyUp: function (e) {
                var k = e.getKey();
                if (this.editable !== false && this.readOnly !== true && (k == $.event.BACKSPACE || !e.isSpecialKey())) {
                    this.lastKey = k;
                    this.dqTask.delay(this.queryDelay);
                }
                jsuper(this);
            },

            // private
            validateBlur: function () {
                return !this.list || !this.list.isVisible();
            },

            // private
            initQuery: function () {
                this.doQuery(this.getRawValue());
            },

            // private
            beforeBlur: function () {
                this.assertValue();
            },

            // private
            postBlur: function () {
                jsuper(this);
                this.collapse();
                this.inKeyMode = false;
            },

            /**
             * Execute a query to filter the dropdown list.  Fires the {@link #beforequery} event prior to performing the
             * query allowing the query action to be canceled if needed.
             * @param {String} query The SQL query to execute
             * @param {Boolean} forceAll <tt>true</tt> to force the query to execute even if there are currently fewer
             * characters in the field than the minimum specified by the <tt>{@link #minChars}</tt> config option.  It
             * also clears any filter previously saved in the current store (defaults to <tt>false</tt>)
             */
            doQuery: function (q, forceAll) {
                q = $.isEmpty(q) ? '' : q;
                var qe = {
                    query: q,
                    forceAll: forceAll,
                    combo: this,
                    cancel: false
                };
                if (this.fireEvent('beforequery', qe) === false || qe.cancel) {
                    return false;
                }
                q = qe.query;
                forceAll = qe.forceAll;
                if (forceAll === true || (q.length >= this.minChars)) {
                    if (this.lastQuery !== q) {
                        this.lastQuery = q;
                        if (this.mode == 'local') {
                            this.selectedIndex = -1;
                            if (forceAll) {
                                this.jde.clearFilter();
                            } else {
                                var qf = {};
                                qf[this.displayField] = {"liken": q};
                                this.jde.filter(qf);
                            }
                            this.onLoad();
                        } else {
                            /*this.store.baseParams[this.queryParam] = q;
                             this.store.load({
                             params: this.getParams(q)
                             });
                             this.expand();*/
                        }
                    } else {
                        this.selectedIndex = -1;
                        this.onLoad();
                    }
                }
            },

            // private
            getParams: function (q) {
                var p = {};
                //p[this.queryParam] = q;
                if (this.pageSize) {
                    p.start = 0;
                    p.limit = this.pageSize;
                }
                return p;
            },

            /**
             * Hides the dropdown list if it is currently expanded. Fires the {@link #collapse} event on completion.
             */
            collapse: function () {
                if (!this.isExpanded()) {
                    return;
                }
                this.list.hide();
                $.getDoc().off('mousewheel', this.collapseIf, this);
                $.getDoc().off('mousedown', this.collapseIf, this);
                this.fireEvent('collapse', this);
            },

            // private
            collapseIf: function (e) {
                if (!e.within(this.wrap) && !e.within(this.list)) {
                    this.collapse();
                }
            },

            /**
             * Expands the dropdown list if it is currently hidden. Fires the {@link #expand} event on completion.
             */
            expand: function () {
                if (this.isExpanded() || !this.hasFocus) {
                    return;
                }

                if (this.title || this.pageSize) {
                    this.assetHeight = 0;
                    if (this.title) {
                        this.assetHeight += this.header.height();
                    }
                    if (this.pageSize) {
                        this.assetHeight += this.footer.height();
                    }
                }

                if (this.bufferSize) {
                    this.doResize(this.bufferSize);
                    delete this.bufferSize;
                }

                this.list.alignTo.apply(this.list, [this.el].concat(this.listAlign));

                // zindex can change, re-check it and set it if necessary
                var listParent = $.dom(this.getListParent() || $.getBody()),
                    zindex = parseInt($(listParent).css('z-index'), 10);
                if (!zindex) {
                    zindex = this.getParentZIndex();
                }
                if (zindex) {
                    this.list.css('z-index', zindex + 5);
                }
                this.list.show();

                $.getDoc().on("mousewheel mousedown", this.collapseIf, this);

                this.fireEvent('expand', this);
            },

            /**
             * @method onTriggerClick
             * @hide
             */
            // private
            // Implements the default empty TriggerField.onTriggerClick function
            onTriggerClick: function (e) {
                if (this.readOnly || this.disabled) {
                    return;
                }
                if (this.isExpanded()) {
                    this.collapse();
                    this.el.dom().focus();
                } else {
                    this.onFocus({});
                    if (this.triggerAction == 'all') {
                        this.doQuery(this.allQuery, true);
                    } else {
                        this.doQuery(this.getRawValue());
                    }
                    this.el.dom().focus();
                }
            }
        });
    }, 'combobox');
});